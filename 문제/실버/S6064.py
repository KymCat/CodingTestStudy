import sys, math

"""
구글에 문제에 대해 검색해보면 아래와 같은 코딩으로 되어 있다.
            def solution(m,n,x,y) :
                while x <= m * n :
                    if (x-y) % n == 0 :
                        return x
                    x+=m
                return -1

< if (x-y) % n == 0 > 이 부분이 제일 이해가 되지 않았는데, 간단하게 설명해보겠다.
입력이 (5, 3, 4, 2) 이고 이를 순서대로 풀어보면
(x,y) day
(1,1)  1             x,y가 (4,2) 일 때를 찾아야한다.
(2,2)  2             일단 x가 4가 나오는 day를 보면 [4,9,14] 총 3가지고 m이 5이기 때문에 4는 5일에 한번씩 나오는 것이 당연하다.
(3,3)  3             이를 식으로 풀어보면 [x, x+m, x+2m, x+3m, ... x+km] 이런 식으로 이어진다.
(4,1)  4             때문에 [x, x+m, x+2m, x+3m, ... x+km] 들을 모두 m으로 나누면 나머지가 x가 나오는 것도 당연하다.
(5,2)  5             y또한 [y, y+n, y+2n, y+3n, ... y+kn] 이고 n으로 나누면 나머지가 무조건 y다.
(1,3)  6             
(2,1)  7             여기까지 이해가 되었다면 우리가 찾아야 할 것을 다시 상기 시키겠다.
(3,2)  8             우리는 day[4,9,14]에서 y값이 2인 것을 찾아야한다.
(4,3)  9             y가 2가 나오는 day를 보면[2,5,8,11,14] 총 5가지가 나오고, n이 3이기 때문에 3일에 한번씩 나온다.
(5,1)  10            주목해야할건 x,y에서 겹치는 day가 나오는 14인데, day14일때 (4,2)가 나오는 것이다.
(1,2)  11            
(2,3)  12            즉, 겹치는 day가 답이 되는 것이고 겹치는 day가 없다면 답이 없기에 -1을 출력하면 되는 것 !
(3,1)  13            겹치는걸 찾는것이니, x,y중 나는 x를 선택하고 x를 +m씩 증가시키면서, n으로 나눈 나머지가 y인 값을 찾으면 된다.
(4,2)  14            결론은 x % n == y % n를 고쳐쓰면 (x-y) % n == 0 인 것이었다...
(5,3)  15(종말)       EX) 15 % 4 == 3 % 4 >> (15 - 3) % 4 == 0

"""

def solution(m, n, x, y):
    lcm = math.lcm(m, n)  # 종말일은 최소공배수다.
    while x <= lcm:
        if x % n == y % n:  # 10 10 10 10일 경우, -1 출력되어 y 뒤에 % n을 추가함
            return x
        x += m
    return -1


t = int(input())
for _ in range(t):
    m, n, x, y = map(int, sys.stdin.readline().split())
    print(solution(m, n, x, y))

# 진짜 어렵다.